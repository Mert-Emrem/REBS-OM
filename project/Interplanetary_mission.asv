clear 
close all
clc

addpath 'MATLAB functions-20241213'\timeConversion\time\
addpath 'MATLAB functions-20241213'\


%% Interplanetary Explorer Mission

% constant
mu_sun = astroConstants(4);
mu_merc = astroConstants(11);
mu_mars = astroConstants(14);

R_mars = 3390; % mars radius [km]

%% Departure planet: Mercury

T_syn_1 = 100.8882;

dep_date_min = date2mjd2000([2030, 1, 1, 0, 0, 0]);
dep_date_max = date2mjd2000([2060, 1, 1, 0, 0, 0]);
% dep_date_max = dep_date_min + 10*T_syn_1; % ToF_max

dt = 50;

dep_window = dep_date_min: dt :dep_date_max;



[kep, ~] = uplanet_vec(dep_window, 1);

a_merc = kep(1,1);

[r_dep, v_dep] = kep2car_vec(a_merc, kep(2,1), kep(3,1),...
             kep(4,1), kep(5,1), kep(6,:), mu_sun);

% r_dep = [];
% v_dep = [];
% for i=1:length(dep_window)
%     [kep, ~] = uplanet(dep_window(i), 1);
%     [r, v] = kep2car_vec(kep(1), kep(2), kep(3),...
%                  kep(4), kep(5), kep(6), mu_sun);
%     r_dep = [r_dep, r];
%     v_dep = [v_dep, v];
% end

%% Flyby planet: Mars

flyby_window = dep_window;

[kep, ~] = uplanet_vec(flyby_window, 4);

a_mars = kep(1,1);

[r_mars, v_mars] = kep2car_vec(a_mars, kep(2,:), kep(3,:),...
             kep(4,:), kep(5,:), kep(6,:), mu_sun);


%% Arrival asteroid N.40

T_syn_2 = 4.1902;

arr_time_min = date2mjd2000([2030, 1, 1, 0, 0, 0]);
arr_time_max = date2mjd2000([2060, 1, 1, 0, 0, 0]);

arr_dt = 50;

arr_window = arr_time_min: arr_dt: arr_time_max;

[kep, f, ~] = ephAsteroids_vec(arr_window, 40);

a_harmonia = kep(1);
i = kep(3).*ones(1,length(f));
OM = kep(4).*ones(1, length(f));
om =  kep(5).*ones(1, length(f));

[r_harm, v_harm] = kep2car_vec(kep(1), kep(2), i,...
            OM, om, f, mu_sun);

%%

deltaV_Merc_Mars = ones(length(dep_window), length(flyby_window))*NaN;
Vinf_minus = ones(length(dep_window), length(flyby_window),3)*NaN;

for i = 1:length(dep_window)

    for j = 1:length(flyby_window)

        % Compute the time of flight
        ToF = (flyby_window(j) - dep_window(i)) * 86400; % [s]
        
        % Ignore temporally impossible solutions (arrival before departure)
        if ToF > 0
            % Solve Lambert's problem
            [~, ~, ~, err_1, VI, VF, ~, ~] = ...
                lambertMR(r_dep(:, i) , r_mars(:,j) , ...
                ToF, mu_sun, 0, 0, 0);


            % Compute Delta-V
            deltaV_1 = norm(VI' - v_dep(:, i)); % Departure Delta-V
            % deltaV_2 = norm(VF' - v_mars(:,j)); % Arrival Delta-V
            deltaV_2 = 0;

            if err_1 == 0
            deltaV_Merc_Mars(i, j) = deltaV_1+deltaV_2;
            Vinf_minus(i,j,:) = VF' - v_mars(:,j);
            end
            % deltaV_Merc_Mars(i, j) = deltaV_1+deltaV_2;
            % Vinf_minus(i,j,:) = VF' - v_mars(:,j);

        end

    end

end

Merc_Mars_3d = repmat(deltaV_Merc_Mars, [1, 1, length(arr_window)]);


porkchopPlotter(deltaV_Merc_Mars, flyby_window, dep_window)


%%

deltaV_Mars_Harm = ones(length(flyby_window), length(arr_window))*NaN;
Vinf_plus = ones(length(flyby_window), length(arr_window),3)*NaN;

for i = 1:length(flyby_window)

    for j = 1:length(arr_window)

        % Compute the time of flight
        ToF = (arr_window(j) - flyby_window(i)) * 86400; % [s]
        
        % Ignore temporally impossible solutions (arrival before departure)
        if ToF > 0
            % Solve Lambert's problem
            [~, ~, ~, err_2, VI, VF, ~, ~] = ...
                lambertMR(r_mars(:, i) , r_harm(:,j) , ...
                ToF, mu_sun, 0, 0, 0);

            % Compute Delta-V
            % deltaV_1 = norm(VI' - v_mars(:,i)); % Departure Delta-V
            deltaV_2 = norm(VF' - v_harm(:,j)); % Arrival Delta-V
            deltaV_1 = 0;

            if err_2 == 0
               deltaV_Mars_Harm(i, j) = deltaV_1+deltaV_2;
               Vinf_plus(i,j,:) = VI' - v_mars(:,i);
            end
               % deltaV_Mars_Harm(i, j) = deltaV_1+deltaV_2;
               % Vinf_plus(i,j,:) = VI' - v_mars(:,j);

        end
    end

end

Mars_Harm_3d = repmat(deltaV_Mars_Harm, [1, 1, length(dep_window)]);
M1 = Mars_Harm_3d;
Merc_Mars_3d = permute(Merc_Mars_3d, [2, 3, 1]);
M2 = Merc_Mars_3d;


porkchopPlotter(deltaV_Mars_Harm, arr_window, dep_window)


%%

Delta_GA = ones(length(flyby_window), length(arr_window), length(dep_window))*NaN;
DeltaVtot = ones(length(flyby_window), length(arr_window), length(dep_window))*NaN;

for i=1:length(flyby_window)

    for j=1:length(arr_window)

        for k=1:length(dep_window)

             if dep_window(k)<flyby_window(i) && flyby_window(i)<arr_window(j)

             vinf_m = squeeze(Vinf_minus(k,i,:));
             vinf_p = squeeze(Vinf_plus(i,j,:));
             dvp  = PowerGravityAssist(vinf_m, vinf_p...
                    ,R_mars, 100, mu_mars);

             Delta_GA(i, j, k) = dvp;

                  if not(isnan(dvp)) &&...
                     not(isnan(M1(i, j, k))) && ...
                     not(isnan(M2(i, j, k)))
    
                     DeltaVtot(i,j,k) = dvp + M1(i, j, k) + M2(i, j, k);
    
                  end

             end

        end

    end

end


%%

DeltaV_3dofs_Plotter(DeltaVtot, 200, 180)
[Opt, idx] = min(DeltaVtot(:));
[row, col, depth] = ind2sub(size(DeltaVtot), idx);
t_flyby = flyby_window(row);
t_arr = arr_window(col);
t_dep = dep_window(depth);


%% plot

plotTransfer([t_dep, t_flyby, t_arr],r_dep, r_mars, r_harm)

%%
% figure;
% % 
% planet = 'Sun';
% opts.Units = 'km';
% opts.Position = [0, 0, 0];
% 
% planet3D(planet, opts);
% view([54, 32])
% hold on
% 
% x = r_dep(1,1);
% y = r_dep(2,1);
% z = r_dep(3,1);
% 
% % line=animatedline(x, y, z,'color', '#ffff00', 'LineWidth',2);
% line = animatedline;
% 
% for t = 1:size(r_dep,2)
% 
%         x = r_dep(1, t);
%         y = r_dep(2, t);
%         z = r_dep(3, t);
% 
% 
%         addpoints(line, x, y, z);
% 
%         drawnow;
% 
%         pause(0.01);
% 
% end


%%

N_runs = 10; % Number of runs
% To check algorithm convergence set N_runs > 1.

data.R_mars = R_mars;
data.mu_mars = mu_mars;

% Save results for each run:
x_runs = [];
dv_runs = [];

disp(['fmincon search with ',num2str(N_runs),' runs running..']);
tic

x0 = [t_dep, t_flyby, t_arr];


data.h = 100;

for i = 1:N_runs

options=optimoptions("fmincon");
[x_ga, dv_ga] = fmincon(@(x) dvFun(x, data), x0, [], [], [], [],...
            [dep_window(1), 100, 100],...
            [dep_window(end), 10950,...
            arr_window(end)-dep_window(1)], @(x) nonlcon(x, data), options);
x_ga = cumsum(x_ga);

dv_runs = [dv_runs; dv_ga];
x_runs = [x_runs; x_ga];

end

toc

% Convergence check if N_runs > 1:
if N_runs > 1
    
    max_difference = max(dv_runs) - min(dv_runs);
    
end

% Select minimum deltaV solution:

[~,index] = min(dv_runs);
dv_ga = dv_runs(index);
x_ga = x_runs(index,:);

% N_runs = 10; % Number of runs
% % To check algorithm convergence set N_runs > 1.
% 
% data.R_mars = R_mars;
% data.mu_mars = mu_mars;
% 
% % Save results for each run:
% x_runs = [];
% dv_runs = [];
% 
% disp(['fmincon search with ',num2str(N_runs),' runs running..']);
% tic
% 
% x0 = [t_dep, t_flyby, t_arr];
% 
% 
% data.h = 100;
% 
% for i = 1:N_runs
% 
% options=optimoptions("fmincon");
% [x_ga, dv_ga] = fmincon(@(x) dvFun(x, data), x0, [], [], [], [],...
%             [dep_window(1), dep_window(1), arr_window(1)-dep_window(1)],...
%             [dep_window(end)-dep_window(1), dep_window(end)-dep_window(1),...
%             arr_window(end)-dep_window(1)], @(x) nonlcon(x, data), options);
% x_ga = cumsum(x_ga);
% 
% dv_runs = [dv_runs; dv_ga];
% x_runs = [x_runs; x_ga];
% 
% end
% 
% toc
% 
% % Convergence check if N_runs > 1:
% if N_runs > 1
% 
%     max_difference = max(dv_runs) - min(dv_runs);
% 
% end
% 
% % Select minimum deltaV solution:
% 
% [~,index] = min(dv_runs);
% dv_ga = dv_runs(index);
% x_ga = x_runs(index,:);



% Vinf_minus_val = vecnorm(Vinf_minus,2,1);
% Vinf_plus_val = vecnorm(Vinf_plus,2,1);
% 
% delta_val = acos(dot(Vinf_minus, Vinf_plus)./(Vinf_minus_val.*Vinf_plus_val));
% 
% e = @(r_p, v_inf) 1+ (r_p.*(v_inf).^2)/mu_mars;
% 
% delta = @(r_p, v_inf) 2*asin(1./e(r_p, v_inf));
% 
% f_delta = @(r_p)...
%             delta_val - (delta(r_p, Vinf_minus_val)/2 + delta(r_p, Vinf_plus_val)/2);
% 
% h_atm = 100000;
% 
% r_min = (R_mars + h_atm).*ones(1,length(flyby_window));
% 
% if (f_delta(r_min)<=0)&&(f(1e10)>0)
% 
% tol = 1e-14;
% options = optimoptions('fsolve', 'TolFun', tol, 'TolX', tol);
% 
% r_p = fsolve(f_delta, r_min, options);
% 
% 
% e_minus = e(r_p, Vinf_minus_val);
% a_minus = r_p/(1-e_minus);
% 
% e_plus = e(r_p, Vinf_plus_val);
% a_plus = r_p/(1-e_plus);
% 
% delta_v_flyby = Vinf_minus_val- Vinf_plus_val;
% 
% h_GA = r_p - R_mars;
% 
% v_p_minus = sqrt(Vinf_minus_val.^2 + 2*mu_mars./r_p);
% v_p_plus = sqrt(Vinf_plus_val.^2 + 2*mu_mars./r_p);
% 
% delta_V_poweredFB = abs(v_p_plus - v_p_minus);
% 
% else
%     delta_V_poweredFB = NaN;
%     r_p = NaN;
% 
% end

